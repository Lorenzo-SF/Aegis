defmodule Aegis.Printer do
  @moduledoc """
  Pintado de mensajes en terminal con colores, alineaciones, tablas, animaciones, menús, etc.

  Nivel 2 del framework - CLI/TUI. Depende de Aurora (1A) y Pandr (1B).
  """
  require Argos.Command
  require Logger

  alias Aurora.{Color, Convert, Format}
  alias Aurora.Structs.{ChunkText, ColorInfo, EffectInfo, FormatInfo}
  alias Aegis.Tui.Terminal
  alias Aegis.{Animation, Terminal}

  @default_separator_char "="
  @default_separator_color :secondary
  @default_separator_align :left
  @micro_header Application.compile_env(:aegis, :logos)[:micro_header]
  @short_header Application.compile_env(:aegis, :logos)[:short_header]
  @long_header Application.compile_env(:aegis, :logos)[:long_header]
  @header_message Application.compile_env(:aegis, :messages)[:header_message]
  @description_message Application.compile_env(:aegis, :messages)[:description_message]

  @doc """
  Print a formatted message to the terminal.

  ## Options

  - `:message` - String message to print
  - `:chunks` - List of ChunkText structs for complex formatting
  - `:messages` - List of messages to be converted to chunks
  - `:color` - Color atom (`:primary`, `:secondary`, etc.)
  - `:align` - Alignment (`:left`, `:center`, `:right`)
  - `:add_line` - Add line breaks (`:none`, `:before`, `:after`, `:both`)

  ## Examples

      iex> Pandr.Printer.message(message: "Hello", color: :primary)
      :ok

      iex> Pandr.Printer.message(message: "Centered", align: :center)
      :ok
  """
  @spec message(keyword()) :: :ok
  def message(opts) do
    Animation.stop()

    opts
    |> build_format_info()
    |> Format.format()
    |> IO.puts()
  end

  @doc """
  Print a raw positioned message without stopping animations or clearing lines.

  This function is specifically designed for TUI mode where we want to position
  text at specific coordinates without interfering with existing content.

  ## Options

  - `:message` - String message to print
  - `:messages` - List of messages to be converted to chunks
  - `:chunks` - List of ChunkText structs for complex formatting
  - `:pos_x` - X coordinate (column) for positioning
  - `:pos_y` - Y coordinate (row) for positioning
  - `:color` - Color atom (`:primary`, `:secondary`, etc.)

  ## Examples

      iex> Pandr.Printer.raw_message(message: "Hello", pos_x: 10, pos_y: 5, color: :primary)
      :ok

      iex> Pandr.Printer.raw_message(messages: chunks, pos_x: 10, pos_y: 5)
      :ok
  """
  @spec raw_message(keyword()) :: :ok
  def raw_message(opts) do
    opts
    |> Keyword.put(:mode, :raw)
    |> build_format_info()
    |> Format.format()
    |> IO.write()
  end

  @doc """
  Breadcrumbs en modo RAW, con posiciones fijas.
  """
  def breadcrumbs_raw(breadcrumbs, opts \\ []) when is_list(breadcrumbs) do
    pos_x = Keyword.get(opts, :pos_x, 0)
    pos_y = Keyword.get(opts, :pos_y, 0)
    sep = " > "

    gradient_colors = Map.values(Color.gradients())

    colored_chunks =
      breadcrumbs
      |> Enum.with_index()
      |> Enum.map(fn {crumb, idx} ->
        default_color = Enum.at(gradient_colors, idx, Color.resolve_color(:no_color))

        case crumb do
          %ChunkText{} = chunk -> chunk
          _ -> %ChunkText{text: to_string(crumb), color: Color.resolve_color(default_color)}
        end
      end)
      |> Enum.intersperse(%ChunkText{text: sep, color: Color.resolve_color(:no_color)})

    {chunks_with_pos, _} =
      Enum.map_reduce(colored_chunks, pos_x, fn chunk, acc_x ->
        width = String.length(chunk.text)
        updated_chunk = %ChunkText{chunk | pos_x: acc_x, pos_y: pos_y}
        {updated_chunk, acc_x + width}
      end)

    raw_message(chunks: chunks_with_pos, manual_tabs: 0, add_line: :both, align: :left)
  end

  @doc """
  Create a progress bar string in raw mode.
  """
  @spec bar_raw(integer(), integer()) :: String.t()
  def bar_raw(parte, total) when is_integer(parte) and is_integer(total),
    do: bar_raw(to_string(parte), to_string(total))

  @spec bar_raw(String.t(), String.t()) :: String.t()
  def bar_raw(parte, total) when is_binary(parte) and is_binary(total) do
    with <<_::binary>> <- parte,
         <<_::binary>> <- total,
         true <- String.match?(parte, ~r/\d/),
         true <- String.match?(total, ~r/\d/),
         u when is_integer(u) <-
           parte |> String.replace(~r/[^\d]/, "") |> String.slice(0..5) |> String.to_integer(),
         t when is_integer(t) and t > 0 <-
           total |> String.replace(~r/[^\d]/, "") |> String.slice(0..5) |> String.to_integer() do
      pct = min(100, div(u * 100, t))
      llenos = div(pct, 10)
      vacios = 10 - llenos

      "[#{String.duplicate("●", llenos)}#{String.duplicate("○", vacios)} #{String.pad_leading(to_string(pct), 2, "0")}%]"
    else
      _ -> "[????]"
    end
  end

  @doc """
  Generate table content as raw positioned messages.
  """
  @spec table_raw(list(), list(), keyword()) :: :ok
  def table_raw(headers, table_rows, opts \\ []) do
    pos_x = Keyword.get(opts, :pos_x, 0)
    pos_y = Keyword.get(opts, :pos_y, 0)
    table_align = Keyword.get(opts, :table_align, :left)
    header_align = Keyword.get(opts, :header_align, [])
    col_align = Keyword.get(opts, :col_align, [])

    all_rows = [headers | table_rows]
    max_cols = get_max_cols(all_rows)
    padded_rows = pad_rows(all_rows, max_cols)
    col_widths = compute_col_widths_raw(padded_rows)

    table_width = Enum.sum(col_widths) + max_cols * 4
    offset_spaces = String.duplicate(" ", get_table_offset_raw(table_width, table_align))

    padded_rows
    |> Enum.with_index()
    |> Enum.each(fn {row, idx} ->
      aligned_row =
        Enum.with_index(row)
        |> Enum.map(fn {chunk, col_idx} ->
          align = get_cell_align_raw(idx, col_idx, header_align, col_align)

          %ChunkText{
            chunk
            | text: pad_cell_text_raw(chunk.text, Enum.at(col_widths, col_idx), align) <> "  ",
              pos_x: pos_x,
              pos_y: pos_y + idx
          }
        end)

      raw_message(
        chunks:
          [
            %ChunkText{
              text: offset_spaces,
              color: Color.get_color_info(:no_color),
              pos_x: pos_x,
              pos_y: pos_y + idx
            }
          ] ++ aligned_row,
        align: :left,
        manual_tabs: 0
      )
    end)

    :ok
  end

  @doc """
  Position cursor at specific coordinates and write text without newline.
  """
  @spec write_at(String.t(), integer(), integer()) :: :ok
  def write_at(text, pos_x, pos_y) do
    IO.write("\e[#{pos_y + 1};#{pos_x + 1}H#{text}")
  end

  @doc """
  Write colored text at specific position without affecting surrounding content.
  """
  @spec write_colored_at(String.t(), keyword()) :: :ok
  def write_colored_at(text, opts) do
    color =
      opts
      |> Keyword.get(:color, :no_color)
      |> Color.get_color_info()

    pos_y = Keyword.get(opts, :pos_y, 0)
    pos_x = Keyword.get(opts, :pos_x, 0)

    text
    |> Format.add_location_to_text(pos_y, pos_x)
    |> Color.apply_color(color)
    |> IO.write()
  end

  @doc """
  Clear a specific line at given Y position.
  """
  @spec clear_line(integer()) :: :ok
  def clear_line(pos_y) do
    IO.write("\e[#{pos_y + 1};1H\e[K")
  end

  @doc """
  Clear a specific portion of a line from start_x to end of line.
  """
  @spec clear_line_portion(integer(), integer()) :: :ok
  def clear_line_portion(y, start_x) do
    ""
    |> Format.add_location_to_text(y, start_x)
    |> IO.write()
  end

  @doc """
  Clear from a specific position to end of line.
  """
  @spec clear_position(integer(), integer()) :: :ok
  def clear_position(pos_y, pos_x) do
    IO.write("\e[#{pos_y + 1};#{pos_x}H\e[K")
  end

  @doc """
  Save cursor position.
  """
  @spec save_cursor() :: :ok
  def save_cursor(), do: IO.write("\e[s")

  @doc """
  Restore cursor position.
  """
  @spec restore_cursor() :: :ok
  def restore_cursor(), do: IO.write("\e[u")

  @doc """
  Position cursor at specific coordinates without writing anything.
  """
  @spec position_cursor(integer(), integer()) :: String.t()
  def position_cursor(y, x) do
    add_location_to_text("", y, x)
  end

  @doc """
  Render a progress bar without clearing the entire line.
  """
  @spec render_progress_bar(integer()) :: String.t()
  def render_progress_bar(progress) do
    bar_length = 20
    filled_length = round(progress * bar_length / 100)
    empty_length = bar_length - filled_length

    filled = String.duplicate("█", filled_length)
    empty = String.duplicate("░", empty_length)

    "[#{filled}#{empty} #{progress}%]"
  end

  # Private helper functions for raw mode
  defp compute_col_widths_raw(rows) do
    0..(length(Enum.at(rows, 0)) - 1)
    |> Enum.map(fn col_idx ->
      rows
      |> Enum.map(fn row -> visible_length_raw(Enum.at(row, col_idx).text) end)
      |> Enum.max()
    end)
  end

  defp get_table_offset_raw(table_width, :center),
    do: div(max(Terminal.terminal_width() - table_width, 0), 2)

  defp get_table_offset_raw(table_width, :right),
    do: max(Terminal.terminal_width() - table_width, 0)

  defp get_table_offset_raw(_, _), do: 0

  defp get_cell_align_raw(row_idx, col_idx, header_aligns, col_aligns) do
    alignments = if row_idx == 0, do: header_aligns, else: col_aligns
    Enum.at(alignments, col_idx, :left)
  end

  defp pad_cell_text_raw(text, width, :left), do: String.pad_trailing(text, width)
  defp pad_cell_text_raw(text, width, :right), do: String.pad_leading(text, width)

  defp pad_cell_text_raw(text, width, :center) do
    left_pad = div(width - String.length(text), 2)
    String.pad_leading(text, String.length(text) + left_pad)
  end

  defp visible_length_raw(str) do
    str
    |> String.replace(~r/\e\[[0-9;]*m/, "")
    |> String.length()
  end

  defp add_location_to_text(text, pos_y, pos_x) do
    "\e[#{pos_y};#{pos_x}H#{text}"
  end

  @doc """
  Build format information from options.

  Converts various option formats into a standardized FormatInfo struct.
  """
  @spec build_format_info(keyword()) :: FormatInfo.t()
  def build_format_info(opts) do
    chunks =
      cond do
        Keyword.has_key?(opts, :chunks) ->
          opts[:chunks]

        Keyword.has_key?(opts, :messages) ->
          Enum.map(opts[:messages], &Convert.to_chunk/1)

        Keyword.has_key?(opts, :message) ->
          [
            Convert.to_chunk(
              {opts[:message], Keyword.get(opts, :color, :no_color)},
              Keyword.get(opts, :pos_x, 0),
              Keyword.get(opts, :pos_y, 0)
            )
          ]

        true ->
          []
      end

    %FormatInfo{
      chunks: chunks,
      align: Keyword.get(opts, :align, :left),
      manual_tabs: Keyword.get(opts, :manual_tabs, -1),
      add_line: Keyword.get(opts, :add_line, :none),
      animation: Keyword.get(opts, :animation, ""),
      mode: Keyword.get(opts, :mode, :normal)
    }
  end

  def separator(opts) do
    size = Keyword.get(opts, :size, :full)
    char = Keyword.get(opts, :char, @default_separator_char)
    color = Keyword.get(opts, :color, @default_separator_color)
    align = Keyword.get(opts, :align, @default_separator_align)
    width = Terminal.terminal_width(size)

    len =
      case size do
        :full -> width
        :half -> div(width, 2)
        :quarter -> div(width, 4)
        n when is_integer(n) and n > 0 -> n
        _ -> width
      end

    message(message: String.duplicate(char, len), color: color, align: align, manual_tabs: 0)
  end

  def header(texts, opts \\ []) do
    color = Keyword.get(opts, :color, :primary)
    align = Keyword.get(opts, :align, :center)
    separator(color: color, align: align)
    Enum.each(texts, fn t -> message(chunks: [Convert.to_chunk({t, color})], align: align) end)
    separator(color: color, align: align)
  end

  def semiheader(text, opts \\ []) do
    color = Keyword.get(opts, :color, :primary)
    align = Keyword.get(opts, :align, :center)
    sep_char = Keyword.get(opts, :sep_char, @default_separator_char)

    separator(char: sep_char, color: color, align: align)
    message(message: text, color: color, align: align, manual_tabs: 3)
  end

  defp message_with_icon(text, icon, opts) do
    color = Keyword.get(opts, :color, Color.get_default_color())
    opts = [messages: [{"#{icon} #{text}", color}]] ++ opts
    message(opts)
  end

  @doc """
  Print an informational message with [i] icon.

  ## Examples

      iex> Aegis.Printer.info("Processing data...")
      :ok
  """
  @spec info(String.t(), :left | :center | :right) :: :ok
  def info(text, align \\ :left),
    do: message_with_icon(text, "[i]", color: :info, align: align, add_line: :none)

  @doc """
  Print a warning message with [!] icon.

  ## Examples

      iex> Pandr.Printer.warning("Be careful with this operation")
      :ok
  """
  @spec warning(String.t(), :left | :center | :right) :: :ok
  def warning(text, align \\ :left),
    do: message_with_icon(text, "[!]", color: :warning, align: align, add_line: :both)

  @doc """
  Print a success message with [✓] icon.

  ## Examples

      iex> Pandr.Printer.success("Operation completed successfully")
      :ok
  """
  @spec success(String.t(), :left | :center | :right) :: :ok
  def success(text, align \\ :left),
    do: message_with_icon(text, "[✓]", color: :success, align: align)

  @doc """
  Print an error message with [X] icon.

  ## Examples

      iex> Pandr.Printer.error("Something went wrong")
      :ok
  """
  @spec error(String.t(), :left | :center | :right) :: :ok
  def error(text, align \\ :left),
    do: message_with_icon(text, "[X]", color: :error, align: align, add_line: :both)

  @doc """
  Print a debug message with [d] icon.

  ## Examples

      iex> Pandr.Printer.debug("Debug information")
      :ok
  """
  @spec debug(String.t(), :left | :center | :right) :: :ok
  def debug(text, align \\ :left),
    do: message_with_icon(text, "[d]", color: :debug, align: align, add_line: :none)

  @doc """
  Print a notice message with [n] icon.

  ## Examples

      iex> Pandr.Printer.notice("Please note this information")
      :ok
  """
  @spec notice(String.t(), :left | :center | :right) :: :ok
  def notice(text, align \\ :left),
    do: message_with_icon(text, "[n]", color: :notice, align: align, add_line: :none)

  @doc """
  Print a critical message with [!C] icon.

  ## Examples

      iex> Pandr.Printer.critical("Critical system error")
      :ok
  """
  @spec critical(String.t(), :left | :center | :right) :: :ok
  def critical(text, align \\ :left),
    do: message_with_icon(text, "[!C]", color: :critical, align: align, add_line: :both)

  @doc """
  Print an alert message with [!A] icon.

  ## Examples

      iex> Pandr.Printer.alert("Alert: immediate attention required")
      :ok
  """
  @spec alert(String.t(), :left | :center | :right) :: :ok
  def alert(text, align \\ :left),
    do: message_with_icon(text, "[!A]", color: :alert, align: align, add_line: :both)

  @doc """
  Print an emergency message with [!!!] icon.

  ## Examples

      iex> Pandr.Printer.emergency("System failure - immediate action required")
      :ok
  """
  @spec emergency(String.t(), :left | :center | :right) :: :ok
  def emergency(text, align \\ :left),
    do: message_with_icon(text, "[!!!]", color: :emergency, align: align, add_line: :both)

  def animation(messages, align \\ :left) do
    Animation.stop()
    Animation.start(messages, align)
  end

  def table(headers, table_rows, opts \\ []) do
    all_rows = [headers | table_rows]
    table_align = Keyword.get(opts, :table_align, :left)
    header_align = Keyword.get(opts, :header_align, [])
    col_align = Keyword.get(opts, :col_align, [])
    add_line = Keyword.get(opts, :add_line, :none)

    max_cols = get_max_cols(all_rows)
    padded_rows = pad_rows(all_rows, max_cols)
    col_widths = compute_col_widths(padded_rows)

    table_width = Enum.sum(col_widths) + max_cols * 4
    offset_spaces = String.duplicate(" ", get_table_offset(table_width, table_align))

    if add_line in [:before, :both], do: IO.puts("")

    Enum.with_index(padded_rows)
    |> Enum.each(fn {row, idx} ->
      aligned_row =
        Enum.with_index(row)
        |> Enum.map(fn {chunk, col_idx} ->
          align = get_cell_align(idx, col_idx, header_align, col_align)

          %ChunkText{
            chunk
            | text: pad_cell_text(chunk.text, Enum.at(col_widths, col_idx), align) <> "  "
          }
        end)

      message(
        chunks:
          [%ChunkText{text: offset_spaces, color: Color.get_color_info(:no_color)}] ++ aligned_row,
        align: :left,
        manual_tabs: 0
      )
    end)

    if add_line in [:after, :both], do: IO.puts("")
  end

  defp get_max_cols(rows), do: rows |> Enum.map(&length/1) |> Enum.max(fn -> 0 end)

  defp pad_rows(rows, max_cols) do
    Enum.map(rows, fn row ->
      row ++
        List.duplicate(
          %ChunkText{text: "", color: Color.get_color_info(:no_color)},
          max_cols - length(row)
        )
    end)
  end

  defp compute_col_widths(rows) do
    0..(length(Enum.at(rows, 0)) - 1)
    |> Enum.map(fn col_idx ->
      rows
      |> Enum.map(fn row -> visible_length(Enum.at(row, col_idx).text) end)
      |> Enum.max()
    end)
  end

  defp get_table_offset(table_width, :center),
    do: div(max(Terminal.terminal_width() - table_width, 0), 2)

  defp get_table_offset(table_width, :right),
    do: max(Terminal.terminal_width() - table_width, 0)

  defp get_table_offset(_, _), do: 0

  # =========================
  # ALINEACIÓN DE CELDAS
  # =========================

  defp get_cell_align(row_idx, col_idx, header_aligns, col_aligns) do
    alignments = if row_idx == 0, do: header_aligns, else: col_aligns
    Enum.at(alignments, col_idx, :left)
  end

  # =========================
  # PAD CELLS
  # =========================
  def pad_cell_text(text, width, :left), do: String.pad_trailing(text, width)
  def pad_cell_text(text, width, :right), do: String.pad_leading(text, width)

  def pad_cell_text(text, width, :center) do
    left_pad = div(width - String.length(text), 2)
    String.pad_leading(text, String.length(text) + left_pad)
  end

  def message_with_gradient(opts) when is_list(opts) do
    Animation.stop()

    gradients =
      opts
      |> Keyword.get(:colors, [])
      |> Enum.map(&Color.resolve_color/1)
      |> Color.expand_gradient_colors()
      |> Enum.map_join("' '", & &1.hex)

    cond do
      Keyword.has_key?(opts, :chunks) ->
        chunks = Keyword.get(opts, :chunks)

        Enum.each(chunks, fn %ChunkText{text: text} ->
          formatted_text = apply_formatting([text], opts)
          cmd = "echo '#{formatted_text}' | gterm '#{gradients}'"
          result = Argos.Command.exec!(cmd)
          IO.puts(result)
        end)

      Keyword.has_key?(opts, :messages) ->
        messages = Keyword.get(opts, :messages)

        if Enum.all?(messages, &is_binary/1) do
          formatted_text =
            messages
            |> Enum.join(" ")
            |> apply_formatting(opts)

          cmd = "echo '#{formatted_text}' | gterm '#{gradients}'"
          result = Argos.Command.exec!(cmd)
          IO.puts(result)
        else
          Enum.each(messages, fn msg -> message(message: msg) end)
        end

      Keyword.has_key?(opts, :message) ->
        message = to_string(Keyword.get(opts, :message))

        formatted_text = apply_formatting([message], opts)
        cmd = "echo '#{formatted_text}' | gterm '#{gradients}'"
        result = Argos.Command.exec!(cmd)
        IO.puts(result)

      true ->
        :ok
    end
  end

  defp apply_formatting(messages, opts) do
    fmt_info = %FormatInfo{
      chunks:
        Enum.map(messages, fn msg ->
          %ChunkText{
            text: msg,
            color: Color.get_color_info(:no_color),
            pos_x: Keyword.get(opts, :pos_x, 0),
            pos_y: Keyword.get(opts, :pos_y, 0)
          }
        end),
      manual_tabs: Keyword.get(opts, :manual_tabs, 0),
      align: Keyword.get(opts, :align, :left),
      add_line: :none,
      animation: Keyword.get(opts, :animation, ""),
      mode: Keyword.get(opts, :mode, :normal)
    }

    Format.format(fmt_info)
  end

  @doc """
  Display a question and wait for user input.

  Displays the question text and waits for user input with a 30-second timeout.
  Returns "n" by default if timeout occurs or if there are input issues.

  ## Parameters

  - `text` - The question text to display
  - `color` - Color of the question text (default: `:primary`)
  - `align` - Text alignment (default: `:left`)

  ## Examples

      iex> Pandr.Printer.question("Continue? (y/n)")
      "y"
  """
  @spec question(String.t(), atom(), :left | :center | :right) :: String.t()
  def question(text, color \\ :primary, align \\ :left) do
    message(message: text, color: color, align: align)

    # Usar método más robusto para obtener input
    try do
      # Asegurar que stdin esté disponible
      case Process.group_leader() do
        pid when is_pid(pid) ->
          # Intentar IO.gets con timeout usando Task
          task =
            Task.async(fn ->
              IO.gets("> ")
            end)

          # 30 seconds timeout
          case Task.yield(task, 30_000) do
            {:ok, result} when is_binary(result) ->
              Task.shutdown(task)
              String.trim(result)

            {:ok, :eof} ->
              Task.shutdown(task)
              Logger.warning("EOF recibido en question, usando 'n' por defecto")
              "n"

            nil ->
              Task.shutdown(task, :brutal_kill)
              Logger.warning("Timeout en question, usando 'n' por defecto")
              "n"

            {:ok, other} ->
              Task.shutdown(task)
              Logger.warning("Input inesperado en question: #{inspect(other)}, usando 'n'")
              "n"
          end

        nil ->
          Logger.warning("No hay group_leader disponible, usando 'n' por defecto")
          "n"
      end
    rescue
      error ->
        Logger.error(
          "Error obteniendo input en question: #{inspect(error)}, usando 'n' por defecto"
        )

        "n"
    catch
      :exit, reason ->
        Logger.error("Exit capturado en question: #{inspect(reason)}, usando 'n' por defecto")
        "n"
    end
  end

  def question_with_options(text, options, color \\ :primary, align \\ :left) do
    answer = question(text, color, align)

    case Enum.find(options, fn {txt, _} -> txt == answer end) do
      nil -> :error
      {_txt, val} -> val
    end
  end

  def yesno(text, color \\ :primary, align \\ :left) do
    case question_with_options(
           text,
           [{"Y", :yes}, {"y", :yes}, {"n", :no}, {"N", :no}],
           color,
           align
         ) do
      :yes -> :yes
      _ -> :no
    end
  end

  def menu(header_text, options, color \\ :primary, align \\ :left) do
    message(message: header_text, color: :info, align: align, manual_tabs: 1)
    Enum.each(options, fn desc -> message(message: desc, color: color, align: align) end)
  end

  def logo(lines, opts \\ []) when is_list(lines) do
    lines
    |> Format.format_logo(opts)
    |> print_logo()
  end

  defp print_logo({lines, []}) do
    IO.puts(lines)
  end

  defp print_logo({lines, gradient_hexes}) do
    gradients = Enum.map_join(gradient_hexes, " ", fn h -> "'#{h}'" end)

    "echo '#{lines}' | gterm #{gradients}"
    |> Argos.Command.exec!()
    |> IO.puts()
  end

  def logo_with_data(opts \\ []) do
    logo = Keyword.get(opts, :logo, get_header_logo())
    align = Keyword.get(opts, :align, :center)

    %{
      name: user_name,
      email: user_email,
      hostname: hostname
    } =
      Keyword.get(opts, :user_info, %{
        name: "",
        email: "",
        hostname: ""
      })

    gradient_colors = Keyword.get(opts, :gradient_colors, Color.gradients())

    replacements = %{
      "{empty_space}" => "",
      "{separator}" => "{separator}",
      "{HEADER_MESSAGE}" => @header_message,
      "{GIT_USER_NAME}" => user_name,
      "{GIT_USER_EMAIL}" => user_email,
      "{HOSTNAME}" => hostname,
      "{DESCRIPTION_MESSAGE}" => @description_message
    }

    logo
    |> Enum.map(&replace_line_variables(&1, replacements))
    |> logo(align: align, gradient_colors: gradient_colors)
  end

  def get_header_logo do
    {width, _height} = Terminal.terminal_size()

    cond do
      width <= 80 -> @micro_header
      width <= 120 -> @short_header
      true -> @long_header
    end
  end

  @doc """
  Imprime el logo usando texto
  """
  def start_logo(opts \\ []) do
    {lines, gradient_hexes} =
      Format.format_logo(Application.get_env(:aegis, :logos)[:start_logo], opts)

    gradients = Enum.map_join(gradient_hexes, " ", fn h -> "'#{h}'" end)

    "echo '#{lines}' | gterm #{gradients}"
    |> Argos.Command.exec!()
    |> IO.puts()
  end

  def bar(parte, total) when is_integer(parte) and is_integer(total),
    do: bar(to_string(parte), to_string(total))

  def bar(parte, total) when is_binary(parte) and is_binary(total) do
    with <<_::binary>> <- parte,
         <<_::binary>> <- total,
         true <- String.match?(parte, ~r/\d/),
         true <- String.match?(total, ~r/\d/),
         u when is_integer(u) <-
           parte |> String.replace(~r/[^\d]/, "") |> String.slice(0..5) |> String.to_integer(),
         t when is_integer(t) and t > 0 <-
           total |> String.replace(~r/[^\d]/, "") |> String.slice(0..5) |> String.to_integer() do
      pct = min(100, div(u * 100, t))
      llenos = div(pct, 10)
      vacios = 10 - llenos

      "[#{String.duplicate("●", llenos)}#{String.duplicate("○", vacios)} #{String.pad_leading(to_string(pct), 2, "0")}%]"
    else
      _ -> "[????]"
    end
  end

  @doc """
  Limpia la pantalla del terminal.
  """
  @spec clear_screen() :: :ok
  def clear_screen do
    Terminal.clear_screen()
    :ok
  end

  def breadcrumbs(breadcrumbs, opts \\ []) when is_list(breadcrumbs) do
    align = Keyword.get(opts, :align, :left)

    sep = " > "

    gradient_colors = Map.values(Color.gradients())

    formated_chunks =
      breadcrumbs
      |> Enum.with_index()
      |> Enum.map(fn {crumb, idx} ->
        default_color = Enum.at(gradient_colors, idx, Color.resolve_color(:no_color))

        case crumb do
          %ChunkText{} = chunk ->
            chunk

          _ ->
            %ChunkText{
              text: to_string(crumb),
              color: Color.resolve_color(default_color)
            }
        end
      end)
      |> Enum.intersperse(%ChunkText{text: sep, color: Color.resolve_color(:no_color)})

    message(
      chunks: formated_chunks,
      manual_tabs: 0,
      add_line: :both,
      align: align
    )
  end

  def examples do
    semiheader("🌈 Ejemplos de colores y efectos 🌈", color: :happy, align: :center)

    Enum.each(
      [
        example_messages(),
        example_raw_messages(),
        example_especials(),
        example_breadcrumbs(),
        example_gradients(),
        example_effects(),
        example_animations(),
        example_tables(),
        example_bar(),
        example_questions(),
        example_menus(),
        example_logos()
      ],
      fn fun ->
        fun.()
      end
    )
  end

  def example_messages do
    colors = Enum.map(Color.colors(), fn {name, %{hex: hex}} -> {"#{name} => #{hex}", hex} end)

    for align <- [:left, :center, :right] do
      Terminal.clear_screen()

      semiheader("Mensajes (align: #{Atom.to_string(align)})",
        color: :happy,
        align: :center
      )

      _chunks =
        Enum.map(colors, fn {msg, hex} ->
          message(
            chunks: [%ChunkText{text: msg, color: Color.get_color_info(hex)}],
            align: align,
            add_line: :none
          )
        end)

      question("Pulsa ENTER para continuar...")
    end

    for align <- [:left, :center, :right] do
      Terminal.clear_screen()

      semiheader("Colores invertidos (align: #{Atom.to_string(align)})",
        color: :happy,
        align: :center
      )

      _chunks =
        Enum.map(colors, fn {msg, hex} ->
          ci = Color.get_color_info(hex)

          message(
            chunks: [%ChunkText{text: msg, color: %ColorInfo{ci | inverted: true}}],
            align: align
          )
        end)

      question("Pulsa ENTER para continuar...")
    end

    multicolor_msgs =
      [%ChunkText{text: "ESTO ES multicolor", color: Color.get_color_info(:happy)}] ++
        Enum.map(Enum.take(colors, 4), fn {msg, hex} ->
          %ChunkText{text: msg, color: Color.get_color_info(hex)}
        end)

    for align <- [:left, :center, :right] do
      Terminal.clear_screen()

      semiheader("Mensajes multicolor (align: #{Atom.to_string(align)})",
        color: :happy,
        align: :center
      )

      message(chunks: multicolor_msgs, align: align)
      question("Pulsa ENTER para continuar...")
    end
  end

  def example_raw_messages do
    cols = 80 |> div(3) |> round()
    lines = 24 |> div(3) |> round()

    Terminal.clear_screen()

    semiheader("Mensajes RAW",
      color: :happy,
      align: :center
    )

    Enum.each([{0, 0}, {8, 8}, {4, 16}, {16, 14}, {cols, lines}], fn {pos_x, pos_y} ->
      Color.colors()
      |> Enum.take(4)
      |> Enum.map(fn {name, %{hex: hex}} ->
        message(
          chunks: [
            %ChunkText{
              text: "#{name} => #{hex}",
              color: Color.get_color_info(hex),
              pos_x: pos_x,
              pos_y: pos_y
            }
          ],
          add_line: :none,
          mode: :raw
        )
      end)
    end)

    question("Pulsa ENTER para continuar...")
  end

  def example_especials do
    for align <- [:left, :center, :right] do
      Terminal.clear_screen()

      semiheader("Mensajes predefinidos (align: #{Atom.to_string(align)})",
        color: :happy,
        align: :center
      )

      info("Esto es un mensaje 'info", align)
      warning("Esto es un mensaje 'warning", align)
      success("Esto es un mensaje 'success", align)
      error("Esto es un mensaje 'error", align)
      debug("Esto es un mensaje 'debug", align)
      notice("Esto es un mensaje 'notice", align)
      critical("Esto es un mensaje 'critical", align)
      alert("Esto es un mensaje 'alert", align)
      emergency("Esto es un mensaje 'emergency", align)
      question("¿Este es un question?", :primary, align) |> IO.write()
      yesno("¿Este es un yesno?", align) |> IO.write()
      question("Pulsa ENTER para continuar...")
    end
  end

  def example_breadcrumbs do
    [c1, c2, c3, c4, c5, c6] =
      Color.colors()
      |> Enum.map(fn {name, %{hex: hex}} -> {"#{name} => #{hex}", hex} end)
      |> Enum.take(6)
      |> Enum.map(fn {_, color} -> color end)

    for align <- [:left, :center, :right] do
      Terminal.clear_screen()
      semiheader("Breadcrums", color: :happy, align: :center)

      breadcrumbs(
        [
          %ChunkText{text: "#{c1} > ", color: Color.get_color_info(c1)},
          %ChunkText{text: "#{c2} > ", color: Color.get_color_info(c2)},
          %ChunkText{text: "#{c3} > ", color: Color.get_color_info(c3)},
          %ChunkText{text: "#{c4} > ", color: Color.get_color_info(c4)},
          %ChunkText{text: "#{c5} > ", color: Color.get_color_info(c5)},
          %ChunkText{text: "#{c6} > ", color: Color.get_color_info(c6)}
        ],
        align
      )

      question("Pulsa ENTER para continuar...")
    end
  end

  def example_gradients do
    colors = Enum.map(Color.colors(), fn {name, %{hex: hex}} -> {"#{name} => #{hex}", hex} end)
    Terminal.clear_screen()
    semiheader("Gradientes", color: :happy, align: :center)

    for n <- 1..6 do
      message_with_gradient(message: "Gradiente con #{n} color(es)", colors: Enum.take(colors, n))
    end

    question("Pulsa ENTER para continuar...")

    Enum.each(1..6, fn idx ->
      Terminal.clear_screen()
      semiheader("headers con gradientes", color: :happy, align: :center)

      example_logo(
        [
          "",
          "  ____  ",
          " / ___| ",
          "| |     ",
          "| |___  ",
          " \\____| ",
          ""
        ],
        align: :center,
        gradient_colors: Enum.take(colors, idx)
      )

      example_logo_with_data(
        [
          "",
          "{separator}",
          "  ____      ",
          " / ___|     {HEADER_MESSAGE}",
          "| |         User: {GIT_USER_NAME} <{GIT_USER_EMAIL}>",
          "| |___      Host: {HOSTNAME}",
          " \\____|.   {DESCRIPTION_MESSAGE}",
          "{separator}",
          ""
        ],
        align: :left,
        gradient_colors: Enum.take(colors, idx)
      )

      question("Pulsa ENTER para continuar...")
    end)
  end

  defp example_effects do
    for align <- [:left, :center, :right] do
      Terminal.clear_screen()
      semiheader("Efectos de Formato ANSI", color: :happy, align: :center)

      effect_message("Bold text", align, bold: true)
      effect_message("Dim text", align, dim: true)
      effect_message("Italic text", align, italic: true)
      effect_message("Underline text", align, underline: true)
      effect_message("Hidden text", align, hidden: true)
      effect_message("Strikethrough text", align, strikethrough: true)
      question("Pulsa ENTER para continuar...")
    end
  end

  defp effect_message(text, align, opts) do
    chunk =
      struct(ChunkText,
        text: text,
        color: Color.get_color_info(:primary),
        effects: build_effect_info(opts)
      )

    message(
      chunks: chunk,
      align: align
    )
  end

  defp build_effect_info(opts) do
    %EffectInfo{
      bold: Keyword.get(opts, :bold, false),
      dim: Keyword.get(opts, :dim, false),
      italic: Keyword.get(opts, :italic, false),
      underline: Keyword.get(opts, :underline, false),
      hidden: Keyword.get(opts, :hidden, false),
      strikethrough: Keyword.get(opts, :strikethrough, false)
    }
  end

  def example_animations do
    for align <- [:left, :center, :right] do
      Terminal.clear_screen()
      semiheader("Animaciones", color: :happy, align: :center)

      Color.colors()
      |> Enum.map(fn {name, %{hex: hex}} -> {"#{name} => #{hex}", hex} end)
      |> Enum.each(fn {msg, hex} ->
        animation([{msg, hex}], align)
        :timer.sleep(400)
      end)

      question("Pulsa ENTER para continuar...", :happy, align)
    end

    Animation.stop()
  end

  def example_tables do
    headers = [
      %ChunkText{text: "Cabecera 12345", color: Color.get_color_info(:primary)},
      %ChunkText{text: "Cabecera 1234", color: Color.get_color_info(:secondary)},
      %ChunkText{text: "Cabecera 123", color: Color.get_color_info(:secondary)},
      %ChunkText{text: "Cabecera 12", color: Color.get_color_info(:secondary)},
      %ChunkText{text: "Cabecera 1", color: Color.get_color_info(:secondary)}
    ]

    table = [
      [
        %ChunkText{text: "Col1", color: Color.get_color_info(:primary)},
        %ChunkText{text: "Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2", color: Color.get_color_info(:secondary)}
      ],
      [
        %ChunkText{text: "Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col1", color: Color.get_color_info(:primary)},
        %ChunkText{text: "", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2", color: Color.get_color_info(:secondary)}
      ],
      [
        %ChunkText{text: "Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col1", color: Color.get_color_info(:primary)},
        %ChunkText{text: "", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2", color: Color.get_color_info(:secondary)}
      ],
      [
        %ChunkText{text: "Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col1", color: Color.get_color_info(:primary)},
        %ChunkText{text: "", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2Col2Col2", color: Color.get_color_info(:secondary)},
        %ChunkText{text: "Col2", color: Color.get_color_info(:secondary)}
      ]
    ]

    for table_align <- [:left, :right, :center] do
      for header_align <- [:left, :right, :center] do
        for row_align <- [:left, :right, :center] do
          Terminal.clear_screen()

          header(
            [
              "Ejemplo tabla",
              "table align : #{Atom.to_string(table_align)}",
              "header align: #{Atom.to_string(header_align)}",
              "row align: #{Atom.to_string(row_align)}"
            ],
            color: :happy,
            align: :center
          )

          table(headers, table,
            table_align: table_align,
            header_aling: header_align,
            col_align: [row_align],
            add_line: :both
          )

          question("Pulsa ENTER para continuar...")
        end
      end
    end
  end

  def example_bar do
    Enum.each([:left, :center, :right], fn align ->
      Color.colors()
      |> Enum.each(&render_color_progress_bar(&1, align))
    end)
  end

  def example_logo(lines, opts) when is_list(lines) do
    logo(lines, opts)
  end

  def example_logo_with_data(lines, opts) when is_list(lines) do
    user_info = %{name: "John Doe", email: "john@example.com", hostname: "host"}

    replacements = %{
      "{empty_space}" => "",
      "{separator}" => String.duplicate("=", 80),
      "{HEADER_MESSAGE}" => "Welcome!",
      "{GIT_USER_NAME}" => user_info.name,
      "{GIT_USER_EMAIL}" => user_info.email,
      "{HOSTNAME}" => user_info.hostname,
      "{DESCRIPTION_MESSAGE}" => "This is a CLI app"
    }

    replaced_lines =
      Enum.map(lines, fn line ->
        Enum.reduce(replacements, line, fn {k, v}, acc -> String.replace(acc, k, v) end)
      end)

    logo(replaced_lines, opts)
  end

  defp render_color_progress_bar({_name, %{hex: hex}}, align) do
    Enum.each(0..100//5, fn progress ->
      message = bar(progress, 100)
      message(message: message, color: hex, align: align)
      :timer.sleep(50)
    end)
  end

  defp replace_line_variables(line, replacements) do
    replaced_line =
      Enum.reduce(replacements, line, fn {key, value}, acc ->
        if String.contains?(acc, key) do
          String.replace(acc, key, to_string(value))
        else
          acc
        end
      end)

    %ChunkText{
      text: replaced_line,
      color: Color.get_color_info(:primary)
    }
  end

  defp visible_length(str) do
    str
    |> String.replace(~r/\e\[[0-9;]*m/, "")
    |> String.length()
  end

  def example_questions do
    Terminal.clear_screen()
    semiheader("Preguntas e interacciones", color: :happy, align: :center)
    
    # Simple question
    question("¿Cuál es tu nombre?", :primary, :left)
    Process.sleep(1000)
    
    # Yes/No question
    yesno("¿Te gusta Elixir?", :secondary, :center)
    Process.sleep(1000)
    
    # Question with options
    question_with_options(
      "¿Qué editor prefieres?",
      ["VS Code", "Neovim", "Emacs", "Nano"],
      :ternary,
      :right
    )
    Process.sleep(2000)
  end

  def example_menus do
    Terminal.clear_screen()
    semiheader("Menús", color: :happy, align: :center)
    
    options = [
      %Aegis.Structs.MenuOption{
        id: 1, 
        name: "Opción 1", 
        description: "Primera opción",
        action_type: :navigation,
        action: :option1
      },
      %Aegis.Structs.MenuOption{
        id: 2, 
        name: "Opción 2", 
        description: "Segunda opción",
        action_type: :navigation,
        action: :option2
      },
      %Aegis.Structs.MenuOption{
        id: 3, 
        name: "Opción 3", 
        description: "Tercera opción",
        action_type: :navigation,
        action: :option3
      }
    ]
    
    menu("Menú de ejemplo", options, :primary, :left)
    Process.sleep(2000)
  end

  def example_logos do
    Terminal.clear_screen()
    semiheader("Logos", color: :happy, align: :center)
    
    start_logo(align: :center)
    Process.sleep(2000)
    
    logo_with_data()
    Process.sleep(2000)
  end
end
